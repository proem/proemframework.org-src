{% extends 'docs_layout.twig' %}
{% block content %}
<div class="well">
  <h3>The Dispatch Component</h3>
  <p>
    While the Dispatch component is probably one of the simplest components within Proem, it also sits at the very heart of the framework. This is the component responsible for taking a
    <em>Route Payload</em> and checking to see if it is able to actually execute it. There is actually very little that requires configuration within the Dispatch component, however it
    does expose what it can. By default, it will receive a <em>Payload</em>, try and instantiate the appropriate object and then call the appropriate method on this object.
  </p>
</div>
<div class="well">
  <a name="#mapping-controllers"></a>
  <h3>Mapping your controller's namepspace.</h3>
  <p>
    Within the standard dispatch object a <em>controllerMap</em> pattern is defined to help map a call to a controller to it's namespace.
  </p>
  <p>
    By default the dispatcher looks for Controllers within a namespace defined using the pattern <em>Module\{:module}\Controller\{:controller}</em> where the tokens <em>{:module}</em> and
    <em>{:controller}</em> are replaced with the module and controller return from the <em>Payload</em>.
  </p>
  <p>
    You can add your own controller mapping to the dispatch object:
  </p>
  <pre class="prettyprint">
    $dispatcher->attachControllerMap('Modules\{:module}\{:controller}Controller');
  </pre>
  <p>
    By default comntroller maps are iterated through in a FIFO fasion, meaning that any new controller maps added to the system wil actually be searched after the default
    controller map. You can however, add a priority as a second argument to attachControllerMap(), allowing maps to be prioritised.
  </p>
  <pre class="prettyprint">
    $dispatcher->attachControllerMap('Modules\{:module}\{:controller}Controller', 10);
  </pre>
  <p>
    This new controller map would now now be searched prior to the default map which default to a priority of 0.
  </p>
</div>
<div class="well">
  <h3>Change *action* method signatures.</h3>
  <p>
    Just as <em>controllerMaps</em> can map a controllers namespace, you can also change the signature of an action method. By default, action methods are named using the pattern {:action}Action
    where the token {:action} as replaced by the action data returning from the payload. You can change this by using:
  </p>
  <pre class="prettyprint">
    $dispatcher->setActionMap('{:action}Whatever');
  </pre>
</div>
<div class="well">
  <h3>The Process of Dispatching a Request</h3>
  <p>
    I said above that the Dispatcher is probably the simplest component within Proem, and it is, that is however, not to say that is a completely straight forward process. There is a lot going on
    at the point where the framework is about to dispatch a request over to userland code.
  <p>
  <p>
    Within Proem, this Dispatch process is broken down into two different parts. There is a <em>Dispatch Staging Area</em> which is where both the <em>Request</em> and <em>Dispatch</em> object get to
    perform the business of resolving a Request. Then there is the actual <em>Dispatch</em> object which simply does the dispatching.
  <p>
</div>
<div class="well">
  <h3>The Dispatch Stage</h3>
  <p>
    As I described briefly above, the <em>Dispatch Stage</em> is an area setup specifically for the <em>Request</em> and <em>Dispatch</em> object to do there work. This area was set aside to try and
    make this process as clear as possible for people trying to follow the code through this process. Instead of jumping back and forth between multiple objects to get this job done, it is all taken care
    of in it's own area.
  </p>
  <h3>So how does it all work?</h3>
  <p>
    Like most things in Proem, <em>Events</em> play a massive part. When the <em>proem.post.in.dispatch</em> event is triggered from within the <em>Bootstrap</em> process the stage is created. When the stage
    is created it automatically starts the process of trying to resolve and dispatch the request by first attaching some event listeners, and then calls a <em>processRoutes()</em>. This process in turn
    triggers a series of Events dependant on various criteria.
  </p>
  <p>
    At this point, it's probably easiest to take a look at the <em>processRoutes()</em> method and then walk through what it is doing:
  </p>
  <pre class="prettyprint">
    protected function processRoutes()
    {
        if ($this->assets->has('router') && $this->assets->has('events')) {
            $assets     = $this->assets;
            $router     = $assets->get('router');
            $dispatched = false;
            while ($payload = $router->route()) {
                $assets->get('events')->trigger(
                    (new RouteMatch('proem.route.match'))->setPayload($payload),
                    function($e) use (&$dispatched, &$assets) {
                        if ($e) {
                            $dispatched = true;
                            $assets->get('events')->trigger(new RouteDispatch('proem.route.dispatch'));
                        }
                    }
                );
                if ($dispatched) {
                    break;
                }
            }

            if (!$dispatched) {
                $assets->get('events')->trigger(new RouteExhausted('proem.route.exhausted'));
            }
        }
    }
  </pre>
  <p>
    The first thing we do is check that we have both a <em>Router</em> and <em>Event Manager</em> asset and setup some local variables. Then, within a while loop we call the <em>Routers route()</em>
    method assigning the <em>Payload</em> it returns to a variable. We then trigger a <em>proem.route.match</em>. This executes a <em>testRoute</em> listener:
  </p>
  <pre class="prettyprint">
    function testRoute($e)
    {
        if ($this->assets->has('dispatch')) {
            return $this->assets->get('dispatch')
                ->setPayload($e->getPayload())
                ->isDispatchable();
        }
    }
  </pre>
  <p>
    This listener assigns the current Payload to the Dispatch object and will return <em>true</em> if the Route is dispatchable. Because this listener returns <em>true</em> it triggers the <em>callback</em> attached to the <em>trigger</em>
    this will in turn set the $dispatched flasg to <em>true</em> and then trigger a <em>proem.route.dispatch</em> event, which in turn executes the <em>dispatch</em> listener which hands control over to
    the <em>Dispatch</em> object to actually <em>dispatch</em> the request.
  </p>
  <pre class="prettyprint">
    public function dispatch($e)
    {
        if ($this->assets->has('dispatch')) {
            $this->assets->get('dispatch')->dispatch();
        }
    }
  </pre>
  <p>
    This process happens within a loop because the Router can potentially return multiple matching routes. If it is determined that a Route can not be dispatched, we simply move on to the next one. If, at
    the end of this process no routes are able to be dispatched then a <em>proem.route.exhausted</em> Event is triggered, this in turn executes the <em>routesExhausted</em> listener which displays a
    very simple 404 page.
  </p>
  <pre class="prettyprint">
    public function routesExhausted($e)
    {
        if ($this->assets->has('response')) {
            $this->assets->get('response')
                ->setHttpStatus(404)
                ->appendToBody('&lt;h3&gt;404 - Page Not Found&lt;/h3&gt;');
        }
    }
  </pre>
  <p>
    Attaching your own listener to the <em>proem.route.exhausted</em> event this page can easily be customised to your requirements.
  </p>
</div>
<div class="well">
  <h3>Overloading the Dispatcher</h3>
  <p>
    The dispatcher is setup within the {{ docLink('filter', 'Dispatch Filter') }}. You can overload the dispatch object with your own by listening for the
    'proem.pre.in.dispatch' event. Once recieved you can reply to this event by setting the 'dispatch.asset' parameter to your dispatch object (which must implement
    the {{ apiLink('Proem.Dispatch.Template') }} interface) wrapped within a {{ docLink('di', 'DI Container') }}.
  </p>
  <pre class="prettyprint">
    $proem
        ->attachEventListener('proem.pre.in.dispatch', function($event) {
            $asset = new \Proem\Service\Asset\Standard;
            $asset->set('MyApp\Dispatch', function() {
                return new MyApp\Dispatch;
            );

            $event->setParam('dispatch.asset', $asset);
            return $event;
        });
    });
  </pre>
</div>
<div class="well">
  <h3>Overloading the Dispatch Stage</h3>
  <p>
    The dispatcher is setup within the {{ docLink('filter', 'Dispatch Filter') }}. You can overload the dispatch object with your own by listening for the
    'proem.pre.in.dispatch' event. Once recieved you can reply to this event by setting the 'dispatch.asset' parameter to your dispatch object (which must implement
    the {{ apiLink('Proem.Dispatch.Template') }} interface) wrapped within a {{ docLink('di', 'DI Container') }}.
  </p>
  <pre class="prettyprint">
    $proem
        ->attachEventListener('proem.pre.in.dispatch', function($event) {
            $asset = new \Proem\Service\Asset\Standard;
            $asset->set('MyApp\DispatchStage', function($a) {
                return new MyApp\DispatchStage($a->getParam('assets'));
            );

            $event->setParam('dispatch.asset', $asset);
            return $event;
        });
    });
  </pre>
</div>
{{ disqus('/docs/dev/dispatch-component') }}
{% endblock %}
