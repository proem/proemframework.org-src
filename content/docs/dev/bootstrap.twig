{% extends 'docs_layout.twig' %}
{% block content %}
<div class="well">
  <h2>The Bootstrap Process</h2>
  <p>
    The process of bootstrapping a framework / application is just a fancy name for <em>setting things up</em>. Generally this
    entails instantiating some objects, setting some parameters and then calling some method to get the framework up and running.
    This usually happens within your index.php file or some other file included into it.
  </p>
  <p>
    In most frameworks, what happens once this process is started is something of a <em>black box</em>, the next thing you know, your
    controller is producing a web page. Unless you have a deep understanding of how the framework works this process can often feel like <em>magic</em>.
  </p>
  <p>
    While this can make it easy to get started building applications with the default functionality your framework provides, it can also
    make the task of customising this process quite daunting to someone who doesn't really want to dig into a frameworks internals.
  </p>
  <div class="alert alert-info">
    One of Proem's main objectives was to <strong>simplify this process</strong> and make the logic <strong>easy to follow, understand</strong> and <strong>customise</strong>.
    Proem does this by making extensive use of Events. Events are triggered at certain points in the execution process, these events can be listened for and can be sent responses.
  </div>
</div>
<div class="well">
  <h3>Bootstrapping Proem</h3>
  <p>
    Bootstrapping the Proem framework with only defaults is as simple as:
  </p>
  <pre class="prettyprint">
    (new \Proem\Proem)->init();
  </pre>
  <p>
    However, that doesn't really help us much. Below, we are going to describe what exactly happens when you call Proem's {{ docLink('bootstrap', 'init()', 'init') }} method, and later
    how you can attach code to {{ docLink('signals', 'Events') }} that will allow you to customise this process.
  </p>
</div>
<div class="well">
  <h3>The Proem Object</h3>
  <p>
    The Proem object is a home for your application and your entire application runs inside of this single object. It is responsible for setting
    up all of the low level infrastructure that your application needs in order to execute. While it is possible to bootstrap Proem without using the Proem object,
    without it, the bootstrap process would be far more tedious. The Proem object provides you with an interface for configuring the framework and your application
    while still allowing a great deal of flexibility through the methods it exposes.
  </p>
  <p>
    So let's have a look at what the Proem object actually does. Starting the with __construct:
  </p>
  <pre class="prettyprint">
    public function __construct()
    {
        $this->events = new Asset;
        $this->events->set('Proem\Signal\Manager\Template', $this->events->single(function($asset) {
            return new SignalManager;
        }));

        $this->serviceManager = new ServiceManager;
    }
  </pre>
  <p>
    Here Proem sets up a {{ docLink('signal', 'Signal Manager') }} and a {{ docLink('service', 'Service Manager') }}.
    (Asset is an alias of {{ hubLink('Proem.Service.Asset.Standard') }}.
    These two objects form the heart of an application built on top of Proem and are passed around the entire bootstrap process and into userland <em>(your application)</em>.
  </p>
  <p>
    So what else? Let's take a look at the actual {{ docLink('bootstrap', 'init()', 'init') }} method:
  </p>
  <a name="init"></a>
  <pre class="prettyprint">
    public function init($environment = null)
    {
        $this->serviceManager->set('events', $this->events);

        $this->events->get()->trigger(
            (new Bootstrap('proem.init'))->setServiceManager($this->serviceManager)->setEnvironment($environment),
            function($response) {
                if ($response instanceof Proem\Filter\Manager\Template) {
                    $this->filterManager = $response;
                }
            }
        );

        if ($this->filterManager === null) {
            $this->filterManager = new FilterManager;
        }

        $this->filterManager
            ->setServiceManager($this->serviceManager)
            ->attachEvent(new Response, FilterManager::RESPONSE_EVENT_PRIORITY)
            ->attachEvent(new Request, FilterManager::REQUEST_EVENT_PRIORITY)
            ->attachEvent(new Route, FilterManager::ROUTE_EVENT_PRIORITY)
            ->attachEvent(new Dispatch, FilterManager::DISPATCH_EVENT_PRIORITY)
            ->init();
    }
  </pre>
  <p>
    From this small snippet it is easy to see that <em>init()</em> stores some events within the Service Manager (these are added via <em><a href="#attach-events">attachEventListener</a></em>), it
    then triggers a <em>Bootstrap</em> event named <em>proem.init</em> and creates a new {{ docLink('filter', 'Filter Manager') }}, passing it our {{ docLink('service', 'Service Manager') }} instance.
  </p>
  <p>
    So WTF is this <em>Filter Manager</em>?
  </p>
</div>
<div class="well">
  <h3>The Bootstrap Filter Chain</h3>
  <p>
    Before I explain what the <em>Bootstrap Filter Chain</em> (Managed by the FilterManager) is and the functionality it provides it's probably a good idea to show you
    a simple example of the <em>Filter Chain</em> pattern used.
  </p>
  <pre class="prettyprint">
    class Event1
    {
        public function execute($events)
        {
            echo "in Event1\n";
            if ($e = next($events)) {
                $e->execute($events);
            }
            echo "out Event1\n";
        }
    }

    class Event2
    {
        public function execute($events)
        {
            echo "in Event2\n";
            if ($e = next($events)) {
                $e->execute($events);
            }
            echo "out Event2\n";
        }
    }

    class Chain {
        private $events;

        public function __construct()
        {
            $this->events[] = new Event1;
            $this->events[] = new Event2;
        }

        public function start()
        {
            current($this->events)->execute($this->events);
        }
    }

    (new Chain)->start();
  </pre>
  <p>
    This is a very simple working example of the pattern used by Proem's filter chain. If you run this code you will see the output:
  </p>
  <pre>
    in Event1
    in Event2
    out Event2
    out Event1
  </pre>
  <p>
    The Chain is basically a collection of objects that have the ability to execute each other in a series without needing to know what the next object in the chain is.
  </p>
  <p>
    While the Proem Filter Chain implementation is quite a bit more robust than this simple example, the basic premise is the same
    and the Proem object's init() method merely kicks off this process. It simply executes a series of events that are specifically designed to
    get the framework up and running.
  </p>
</div>
<div class="well">
  <h3>So what Filter Events are involved in bootstrapping?</h3>
  <p>
    So what Events does Proem's init() method execute? If we look at the <a href="#init">code</a> again you can see the events:
  </p>
  <ul>
    <li>Response</li>
    <li>Request</li>
    <li>Route</li>
    <li>Dispatch</li>
  </ul>
  <p>
    As the names suggest, these Events are responsible for setting up the {{ docLink('io', 'Request') }}, {{ docLink('io', 'Response', 'response') }} {{ docLink('route', 'Routing') }}
    and {{ docLink('dispatch', 'Dispatch') }} parts of the framework.
  </p>
  <p>
    Each of these events extend the {{ hubLink('Proem.Filter.Event.Generic') }} object which is as I said little more robust (along with the {{ hubLink('Proem.Filter.Manager.Standard') }}
    <em>(Chain)</em>) than the simple example shown above.
  </p>
  <p>
    One of the differences is that each of these <em>Filter Events</em> has it's own <strong>in</strong>Bound and <strong>out</strong>Bound methods.
    These basically take the place of the <em>echo "in Event1</em> and <em>echo "out Event1</em> parts of the simple example above.
  </p>
  <p>
    It might be best to illistrate this with an image:
  </p>
  <img src="/assets/media/img/filter-chain-2.png" />
  <p>
    These Filter Events do the bulk of the grunt work in terms of setting up the framework ready to bootstrap an application.
  </p>
</div>
<div class="well">
  <h3>How can we customise this process?</h3>
  <p>
    So now we have an understanding of what happens when we call <em>(new Proem\Proem)->init()</em>, but how can we customise this process? If you look again
    at the {{ hubLink('Proem.Filter.Event.Generic') }} abstract you will notice <strong>pre*</strong> and <strong>post*</strong> methods surround the <strong>inBound</strong>
    and <strong>outBound</strong> methods. These pre / post methods are responsible for publishing {{ docLink('signal', 'Events') }} which we can listen to in order to customise the bootstrap process.
  </p>
  <p>
    This means that the Chain can potentially publish 16 different events that we can listen to using the {{ docLink('signal') }}. On top of that, there is
    the initial "proem.init" event (which we can also see within the <a href="#init">init()</a> code) and some of these events themselves have the potential to again trigger more events
    <em>(the {{ docLink('dispatch', 'dispatch stage') }} comes to mind)</em>. The main Events triggered here are:
  </p>
  <ul>
    <li>proem.init</li>
    <li>proem.pre.in.response</li>
    <li>proem.post.in.response</li>
    <li>proem.pre.in.request</li>
    <li>proem.post.in.request</li>
    <li>proem.pre.in.router</li>
    <li>proem.post.in.router</li>
    <li>proem.pre.in.dispatch</li>
    <li>proem.post.in.dispatch</li>
    <li>proem.pre.out.dispatch</li>
    <li>proem.post.out.dispatch</li>
    <li>proem.pre.out.router</li>
    <li>proem.post.out.router</li>
    <li>proem.pre.out.request</li>
    <li>proem.post.out.request</li>
    <li>proem.pre.out.response</li>
    <li>proem.post.out.response</li>
  </ul>
  <div class="alert alert-info">
    As of 0.6.0 the first thing the Signal Manager does with an Event is checks to see if there are any listeners, if there are no listeners, the Signal Manager does nothing. This
    means that Events have relatively little overhead until they actually have a listener attached. And then, the overhead really depends upon what happens within there communication exchange.
  </div>
</div>
<div class="well">
  <h3>So what do we do with all these events?</h3>
  <p>
    All of the above mentioned events are entry points to the framework. These are the events we can listen for and act upon in order to customise the bootstrap process.
  </p>
  <p>
    For instance, out of the box there are only a minimal set of default  <em>Routes</em> set up by Proem. If we want to add a <em>Route</em> to the <em>Router</em> we can do so by
    waiting for the <em>Router</em> to exist, and then access it and add our <em>Route</em>.
  <p>
</div>
<div class="well">
  {{ anchor('attach-events') }}
  <h3>A simple example, adding a <em>Route</em> to the <em>Router</em></h3>
  <pre class="prettyprint">
    (new \Proem\Proem)->attachEventListener('proem.post.in.router', function($event) {
        $event->getServiceManager()->get('router')->attach(
            'logout', new \Proem\Routing\Route\Standard([
                'rule'      => '/logout',
                'targets'   => ['controller' => 'auth', 'action' => 'logout']
            ])
        );
    })->init();
  </pre>
  <p>
    In this example we can see that the <em>Proem</em> object provides an <em>attachEventListener()</em> method. This method proxies through and attaches listeners
    to the main {{ docLink('signal', 'Signal Manager') }} that is passed around the framework.
  </p>
  <p>
    All Events triggered directly from the Bootstrap Filter Chain are instances of the custom {{ hubLink('Proem.Bootstrap.Signal.Event.Bootstrap') }} event which provides a few extra methods
    that are specific to the bootstrap process.
  </p>
  <p>
    Because we are listening for the <strong>proem.post.in.route</strong> event, the router already exists and is within the <em>Service Manager</em> ready for us to customise. A general rule of thumb
    is that default implementations of objects are added during the inBound() filter Events. These can be overridden completely by sending your own implementation as a response to the applicable
    proem.pre.in.* Event (see {{ docLink('signals', 'The Signal Component', 'event-responses') }}, or can be configured by listening to and responding to the applicable proem.post.in.*
  </p>
  <p>
    But what if we don't want to use the {{ hubLink('Proem.Routing.Router.Standard', 'Standard Router') }}? Using the <em>Events</em> provided we can overload it on the fly.
  </p>
</div>
<div class="well">
  <h3>Overloading provided services</h3>
  <p>
    For whatever reason we have decided that we need our <em>Router</em> to implement a useless <em>helloWorld</em> method. How do we overload the <em>Router</em> that Proem is
    going to provide us with by default? Easy.
  <p>
  <p>
    The <em>Router</em> is created within the Router Filter Chain Event <em>inBound()</em>. All we need do is listen for the <strong>proem.pre.in.route</strong> event and from within our listener, return an
    event with the 'router.asset' parameter set to our new <em>Router</em> wrapped within a {{ docLink('service', 'Service Asset Container') }} (Being sure to pass it a valid url to it's constructor).
  </p>
  <pre class="prettyprint">
    namespace MyApp;

    class Router extends \Proem\Routing\Router\Standard
    {
        public function helloWorld()
        {
            return 'Boo!';
        }
    }

    $proem->attachEventListener('proem.pre.in.route', function($event) {
        $asset = new \Proem\Service\Asset\Generic;
        $event->setParam('router.asset', $asset->set('MyApp\Router', function() use ($event) {
            return new MyApp\Router(
                $event->getServiceManager()->get('request')->getBaseUri()
            );
        }));
        return $event;
    })->init();
  </pre>
</div>
<div class="well">
  <h3>Summary</h3>
  <p>
    I hope this has cleared up a lot about how the bootstrap process is intended to work within Proem. I trust that you can see how easy it is going to be to
    customise this process to your needs.
  </p>
  <p>
    I can also hear people screaming that "by the time I listen for all these events my bootstrap is going to be a mess!". While this might look like the case, once you start
    looking at {{ docLink('modules') }} and {{ docLink('plugins') }} you will see that there are ways around this as well.
  </p>
</div>
{{ disqus('/docs/dev/bootstrap') }}
{% endblock %}
