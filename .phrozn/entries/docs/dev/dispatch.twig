layout: docs/dev.twig
---
<div class="well">
  <h3>The Dispatch Component</h3>
  <p>
    While the Dispatch component is probably one of the simplest components within Proem, it also sits at the very heart of the framework. This is the component responsible for taking a
    <em>Route Payload</em> and checking to see if it is able to actually execute it. There is actually very little that requires configuration within the Dispatch component. By default, it
    will receive a <em>Payload</em>, try and instantiate the appropriate object and then call the appropriate method on this object.
  </p>
  <p>
    By default the dispatcher looks for Controllers within a namespace defined using the pattern <em>Module\:module\Controller\:controller</em> where the tokens <em>:module</em> and <em>:controller</em> are
    replaced with the module and controller contained within the <em>Payload</em>.
  </p>
</div>
<div class="well">
  <a name="#controller-namespaces"></a>
  <h3>Adding a new Controller namespace.</h3>
  <p>
    This pattern is known as a controllerMap, and is actually one area that can be configured. To do so, simply add a new controllerMap to the Dispatch object. For example:
  </p>
  <pre class="prettyprint">
    $dispatcher->attachControllerMap('Modules\:module\:controllerController');
  </pre>
</div>
<div class="well">
  <h3>The Process of Dispatching a Request</h3>
  <p>
    I said above that the Dispatcher is probably the simplest component within Proem, and it is, that is however, not to say that is a completely straight forward process. There is a lot going on
    at the point where the framework is about to dispatch a request over to userland code.
  <p>
  <p>
    Within Proem, this Dispatch process is broken down into two different parts. There is a <em>Dispatch Staging Area</em> which is where both the <em>Request</em> and <em>Dispatch</em> object get to
    perform the business of resolving a Request. Then there is the actual <em>Dispatch</em> object which simply does the dispatching.
  <p>
</div>
<div class="well">
  <h3>The Dispatch Stage</h3>
  <p>
    As I described briefly above, the <em>Dispatch Stage</em> is an area setup specifically for the <em>Request</em> and <em>Dispatch</em> object to do there work. This area was set aside to try and
    make this process as clear as possible for people trying to follow the code through this process. Instead of jumping back and forth between multiple objects to get this job done, it is all taken care
    of in it's own area.
  </p>
  <h3>So how does it all work?</h3>
  <p>
    Like most things in Proem, <em>Events</em> play a massive part. When the <em>proem.post.in.dispatch</em> event is triggered from within the <em>Bootstrap</em> process the stage is created. When the stage
    is created it automatically starts the process of trying to resolve and dispatch the request by first attaching some event listeners, and then calls a <em>processRoutes()</em>. This process in turn
    triggers a series of Events dependant on various criteria.
  </p>
  <p>
    At this point, it's probably easiest to take a look at the <em>processRoutes()</em> method and then walk through what it is doing:
  </p>
  <pre class="prettyprint">
    protected function processRoutes()
    {
        if ($this->assets->has('router') && $this->assets->has('events')) {
            $assets     = $this->assets;
            $router     = $assets->get('router');
            $dispatched = false;
            while ($payload = $router->route()) {
                $assets->get('events')->trigger(
                    (new RouteMatch('proem.route.match'))->setPayload($payload),
                    function($e) use (&$dispatched, &$assets) {
                        if ($e) {
                            $dispatched = true;
                            $assets->get('events')->trigger(new RouteDispatch('proem.route.dispatch'));
                        }
                    }
                );
                if ($dispatched) {
                    break;
                }
            }

            if (!$dispatched) {
                $assets->get('events')->trigger(new RouteExhausted('proem.route.exhausted'));
            }
        }
    }
  </pre>
  <p>
    The first thing we do is check that we have both a <em>Router</em> and <em>Event Manager</em> asset and setup some local variables. Then, within a while loop we call the <em>Routers route()</em>
    method assigning the <em>Payload</em> it returns to a variable. We then trigger a <em>proem.route.match</em>. This executes a <em>testRoute</em> listener:
  </p>
  <pre class="prettyprint">
    function testRoute($e)
    {
        if ($this->assets->has('dispatch')) {
            return $this->assets->get('dispatch')
                ->setPayload($e->getPayload())
                ->isDispatchable();
        }
    }
  </pre>
  <p>
    This listener assigns the current Payload to the Dispatch object and will return <em>true</em> if the Route is dispatchable. Because this listener returns <em>true</em> it triggers the <em>callback</em> attached to the <em>trigger</em>
    this will in turn set the $dispatched flasg to <em>true</em> and then trigger a <em>proem.route.dispatch</em> event, which in turn executes the <em>dispatch</em> listener which hands control over to
    the <em>Dispatch</em> object to actually <em>dispatch</em> the request.
  </p>
  <pre class="prettyprint">
    public function dispatch($e)
    {
        if ($this->assets->has('dispatch')) {
            $this->assets->get('dispatch')->dispatch();
        }
    }
  </pre>
  <p>
    This process happens within a loop because the Router can potentially return multiple matching routes. If it is determined that a Route can not be dispatched, we simply move on to the next one. If, at
    the end of this process no routes are able to be dispatched then a <em>proem.route.exhausted</em> Event is triggered, this in turn executes the <em>routesExhausted</em> listener which displays a
    very simple 404 page.
  </p>
  <pre class="prettyprint">
    public function routesExhausted($e)
    {
        if ($this->assets->has('response')) {
            $this->assets->get('response')
                ->setHttpStatus(404)
                ->appendToBody('&lt;h3&gt;404 - Page Not Found&lt;/h3&gt;');
        }
    }
  </pre>
  <p>
    Attaching your own listener to the <em>proem.route.exhausted</em> event this page can easily be customised to your requirements.
  </p>
</div>
<div class="well" id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_identifier = '/docs/dev/dispatch';
  (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
